# -*- coding: utf-8 -*-
"""final_report.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b1_UVkxDcjZm0f_Z73_I4u9UQML2pFXo
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install mahotas imutils kaggle

# 安裝 Kaggle API，與其他必要的影像處理、機器學習套件
!pip install kaggle mahotas scikit-learn matplotlib opencv-python

import os
import zipfile
import random
import numpy as np
import cv2
import mahotas
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt

# 設定 Kaggle API 並下載資料集
# 將 kaggle.json 上傳到 /content，並設好路徑
#/content/kaggle.json
!mkdir -p ~/.kaggle
!cp /content/drive/MyDrive/kaggle/kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# 下載資料集並解壓縮到 Google Drive
!kaggle datasets download -d zaiyankhan/15scene-dataset -p /content/drive/MyDrive/scene_dataset
with zipfile.ZipFile('/content/drive/MyDrive/scene_dataset/15scene-dataset.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/drive/MyDrive/scene_dataset/15scene')

dataset_path = '/content/drive/MyDrive/scene_dataset/15scene'
output_path = '/content/drive/MyDrive/scene_dataset/output22'  # 存放結果的資料夾
os.makedirs(output_path, exist_ok=True)

# 特徵擷取（顏色+紋理）
def describe(image):
    # 轉 HSV 空間，取三個通道的均值與標準差
    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    (means, stds) = cv2.meanStdDev(image)
    colorStats = np.concatenate([means, stds]).flatten()

    # 紋理特徵 (Haralick)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    textures = mahotas.features.haralick(gray).mean(axis=0)

    # 結合成單一特徵向量
    return np.hstack([colorStats, textures])

# 資料集整理
# 資料集整理：將資料夾編號對應成實際場景名稱
folder_map = {
    "00": "bedroom",
    "01": "house",
    "02": "industrial",
    "03": "kitchen",
    "04": "living_room",
    "05": "coast",
    "06": "forest",
    "07": "highway",
    "08": "building",
    "09": "mountain",
    "10": "suburb",
    "11": "inside_city",
    "12": "tall_building",
    "13": "office",
    "14": "store"
}

imagePaths = []
labels = []

for root, dirs, files in os.walk(dataset_path):
    for file in files:
        if file.endswith('.jpg') or file.endswith('.png'):
            folder_id = os.path.basename(root)  # e.g. "04"
            label = folder_map.get(folder_id)
            if label:  # 確保是有效對應
                imagePaths.append(os.path.join(root, file))
                labels.append(label)

data = []
for (imagePath, label) in zip(imagePaths, labels):
    image = cv2.imread(imagePath)
    features = describe(image)
    data.append(features)

data = np.array(data)
labels = np.array(labels)

# 訓練與測試集切分
(trainX, testX, trainY, testY) = train_test_split(
    data, labels, test_size=0.25, random_state=42)

# 建立分類器 (Decision Tree / Random Forest)
use_forest = False  # 改 True 就會用 Random Forest

if use_forest:
    model = RandomForestClassifier(n_estimators=100, random_state=42)
else:
    model = DecisionTreeClassifier(random_state=42)

model.fit(trainX, trainY)

# 預測並輸出結果
predictions = model.predict(testX)
report = classification_report(testY, predictions)
print(report)

# 儲存報告
with open(os.path.join(output_path, 'classification_report.txt'), 'w') as f:
    f.write(report)

# 視覺化預測結果（隨機抽樣100張）
sample_idxs = random.sample(range(len(testX)), 100)
for idx in sample_idxs:
    imagePath = imagePaths[idx]
    image = cv2.imread(imagePath)
    image = cv2.resize(image, (256, 256))

    true_label = testY[idx]
    pred_label = predictions[idx]

    cv2.putText(image, f'True: {true_label}', (10, 20),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
    cv2.putText(image, f'Pred: {pred_label}', (10, 50),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    save_path = os.path.join(output_path, f'sample_{idx}.jpg')
    cv2.imwrite(save_path, image)

    # 顯示結果
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# 安裝 Kaggle API，與其他必要的影像處理、機器學習套件
!pip install kaggle mahotas scikit-learn matplotlib opencv-python

import os
import zipfile
import random
import numpy as np
import cv2
import mahotas
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt

# --- 2. 設定 Kaggle API 並下載資料集
# 將 kaggle.json 上傳到 /content，並設好路徑
#/content/kaggle.json
!mkdir -p ~/.kaggle
!cp /content/drive/MyDrive/kaggle/kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# 下載資料集並解壓縮到 Google Drive
!kaggle datasets download -d zaiyankhan/15scene-dataset -p /content/drive/MyDrive/scene_dataset
with zipfile.ZipFile('/content/drive/MyDrive/scene_dataset/15scene-dataset.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/drive/MyDrive/scene_dataset/15scene')

dataset_path = '/content/drive/MyDrive/scene_dataset/15scene'
output_path = '/content/drive/MyDrive/scene_dataset/output33'  # 存放結果的資料夾
os.makedirs(output_path, exist_ok=True)

# --- 3. 特徵擷取（顏色+紋理）
def describe(image):
    # 轉 HSV 空間，取三個通道的均值與標準差
    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    (means, stds) = cv2.meanStdDev(image)
    colorStats = np.concatenate([means, stds]).flatten()

    # 紋理特徵 (Haralick)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    textures = mahotas.features.haralick(gray).mean(axis=0)

    # 結合成單一特徵向量
    return np.hstack([colorStats, textures])

# 資料集整理
# 資料集整理：將資料夾編號對應成實際場景名稱
folder_map = {
    "00": "inside_city",
    "01": "tall_building",
    "02": "street",
    "03": "highway",
    "04": "coast",
    "05": "open_country",
    "06": "mountain",
    "07": "forest",
    "08": "suburb",
    "09": "industrial",
    "10": "store",
    "11": "bedroom",
    "12": "kitchen",
    "13": "living_room",
    "14": "office"
}

imagePaths = []
labels = []

# for迴圈讀資料集路徑下所有子資料夾與圖片檔案
for root, dirs, files in os.walk(dataset_path):
    for file in files:
        if file.endswith('.jpg') or file.endswith('.png'):  # 只處理jpg或png圖片檔案
            folder_id = os.path.basename(root)  # 取得圖片所在的資料夾名稱（ "04"）
            label = folder_map.get(folder_id)  # 根據對照表取得對應的場景名稱（轉換成lable像是coast）
            if label:  # 如果成功取得label
                imagePaths.append(os.path.join(root, file))  # 儲存圖片完整路徑
                labels.append(label)  # 儲存對應的場景名稱標籤

# 對所有圖片做特徵擷取
data = []
for (imagePath, label) in zip(imagePaths, labels):  # 同時遍歷圖片路徑與標籤
    image = cv2.imread(imagePath)  # 讀取圖片
    features = describe(image)  # 提取圖片的顏色與紋理特徵
    data.append(features)  # 將特徵向量加入資料清單

# 將資料與標籤轉換為 NumPy 陣列(方便訓練模型)
data = np.array(data)
labels = np.array(labels)


#訓練與測試集切分
(trainX, testX, trainY, testY) = train_test_split(
    data, labels, test_size=0.25, random_state=42)

# 建立Decision Tree
use_forest = False  # False = Decision tree, True = Random Forest

if use_forest:
    model = RandomForestClassifier(n_estimators=100, random_state=42)
else:
    model = DecisionTreeClassifier(random_state=42)

model.fit(trainX, trainY)

# 預測並輸出結果
predictions = model.predict(testX)
report = classification_report(testY, predictions)
print(report)


# 儲存報告
with open(os.path.join(output_path, 'classification_report.txt'), 'w') as f:
    f.write(report)

# 視覺化預測結果（隨機抽樣100張）
sample_idxs = random.sample(range(len(testX)), 100)
for idx in sample_idxs:
    imagePath = imagePaths[idx]
    image = cv2.imread(imagePath) # 讀圖片
    image = cv2.resize(image, (256, 256)) # 將圖片縮放至固定大小

    true_label = testY[idx] # 取得圖片的True的場景label
    pred_label = predictions[idx] # 取得模型預測的label結果

    # 在圖片左上方加上「True: 真實label」
    # 在下方加上「Pred: 預測label」的文字(紅色表示模型預測結果)
    cv2.putText(image, f'True: {true_label}', (10, 20),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
    cv2.putText(image, f'Pred: {pred_label}', (10, 50),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

    save_path = os.path.join(output_path, f'sample_{idx}.jpg')
    cv2.imwrite(save_path, image)

    # 顯示結果
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()